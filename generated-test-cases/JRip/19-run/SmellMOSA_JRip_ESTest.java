/*
 * This file was automatically generated by EvoSuite
 * Thu Dec 10 10:58:33 GMT 2015
 */

package weka.classifiers.rules;

import static org.junit.Assert.*;
import org.junit.Test;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteLocalAddress;
import org.evosuite.runtime.testdata.EvoSuiteRemoteAddress;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.junit.runner.RunWith;
import weka.classifiers.rules.JRip;
import weka.classifiers.rules.RuleStats;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true) 
public class JRip_ESTest extends JRip_ESTest_scaffolding {

  //Test case number: 0
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.toString()Ljava/lang/String;: I7 Branch 177 IFNONNULL L2027 - false
   */

  @Test
  public void test00()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.toString();
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals("JRIP: No model built yet.", string0);
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 1
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I65 Branch 107 IFEQ L1638 - false
   */

  @Test
  public void test01()  throws Throwable  {
      JRip jRip0 = new JRip();
      FastVector<Attribute> fastVector0 = new FastVector<Attribute>();
      Instances instances0 = new Instances("\nrevDL: ", (ArrayList<Attribute>) fastVector0, 0);
      try {
        Instances instances1 = jRip0.rulesetForOneClass(3920.533206774, instances0, 1.0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Class index is negative (not set)!
         //
      }
  }

  //Test case number: 2
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.toString(Lweka/core/Attribute;)Ljava/lang/String;: I14 Branch 43 IFLE L1416 - true
   */

  @Test
  public void test02()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      Attribute attribute0 = new Attribute("EiY'`n", 631);
      String string0 = jRip_RipperRule0.toString(attribute0);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertEquals(" => EiY'`n=", string0);
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
  }

  //Test case number: 3
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.grow(Lweka/core/Instances;)V: I9 Branch 7 IFNE L1197 - false
   */

  @Test
  public void test03()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      try {
        jRip_RipperRule0.grow((Instances) null);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         //  Consequent not set yet.
         //
      }
  }

  //Test case number: 4
  /*
   * 6 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.grow(Lweka/core/Instances;)V: I9 Branch 7 IFNE L1197 - true
   * Goal 2. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I40 Branch 104 IFEQ L1632 - true
   * Goal 3. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I52 Branch 105 IFNE L1635 - false
   * Goal 4. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I57 Branch 106 IFEQ L1635 - false
   * Goal 5. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I65 Branch 107 IFEQ L1638 - true
   * Goal 6. weka.classifiers.rules.JRip.rulesetForOneClass(DLweka/core/Instances;DD)Lweka/core/Instances;: I214 Branch 112 IFEQ L1672 - true
   */

  @Test
  public void test04()  throws Throwable  {
      JRip jRip0 = new JRip();
      jRip0.setUsePruning(false);
      try {
        Instances instances0 = jRip0.rulesetForOneClass((-3.0), (Instances) null, (-3.0), 1.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  //Test case number: 5
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.hasAntds()Z: I7 Branch 3 IFNONNULL L1149 - true
   * Goal 2. weka.classifiers.rules.JRip$RipperRule.hasAntds()Z: I20 Branch 4 IFLE L1152 - true
   */

  @Test
  public void test05()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      boolean boolean0 = jRip_RipperRule0.hasAntds();
      assertTrue(jRip0.getUsePruning());
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertFalse(boolean0);
  }

  //Test case number: 6
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.covers(Lweka/core/Instance;)Z: I16 Branch 1 IF_ICMPGE L1132 - true
   */

  @Test
  public void test06()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      int[] intArray0 = new int[2];
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance((double) 3, intArray0, 0);
      boolean boolean0 = jRip_RipperRule0.covers((Instance) binarySparseInstance0);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertTrue(boolean0);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 7
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.covers(Lweka/core/Instance;)Z: I13 Branch 71 IFNE L1039 - false
   * Goal 2. weka.classifiers.rules.JRip$NominalAntd.covers(Lweka/core/Instance;)Z: I27 Branch 72 IF_ICMPNE L1040 - false
   */

  @Test
  public void test07()  throws Throwable  {
      JRip jRip0 = new JRip();
      String[] stringArray0 = new String[7];
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Attribute attribute0 = new Attribute(stringArray0[6], (List<String>) linkedList0);
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      int[] intArray0 = new int[6];
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance((double) 2, intArray0, 2);
      boolean boolean0 = jRip_NominalAntd0.covers((Instance) binarySparseInstance0);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(boolean0);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 8
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.splitData(Lweka/core/Instances;DD)[Lweka/core/Instances;: I21 Branch 65 IF_ICMPGE L993 - false
   */

  @Test
  public void test08()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("", (List<String>) null, 2597);
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      // Undeclared exception!
      try {
        Instances[] instancesArray0 = jRip_NominalAntd0.splitData((Instances) null, (double) 0, 2.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  //Test case number: 9
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.splitData(Lweka/core/Instances;DD)[Lweka/core/Instances;: I21 Branch 65 IF_ICMPGE L993 - true
   */

  @Test
  public void test09()  throws Throwable  {
      JRip jRip0 = new JRip();
      Vector<String> vector0 = new Vector<String>();
      Attribute attribute0 = new Attribute("8118", (List<String>) vector0);
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      // Undeclared exception!
      try {
        Instances[] instancesArray0 = jRip_NominalAntd0.splitData((Instances) null, 0.0, 2.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  //Test case number: 10
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.toString()Ljava/lang/String;: I8 Branch 64 IFNE L927 - false
   */

  @Test
  public void test10()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("X-3Ib;;'6%<2n");
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      String string0 = jRip_NumericAntd0.toString();
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertEquals("X-3Ib;;'6%<2n <= NaN", string0);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(Double.NaN, jRip_NumericAntd0.getCover(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 11
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.covers(Lweka/core/Instance;)Z: I22 Branch 61 IFNE L908 - true
   * Goal 2. weka.classifiers.rules.JRip$NumericAntd.covers(Lweka/core/Instance;)Z: I56 Branch 63 IFGE L912 - false
   */

  @Test
  public void test11()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("X-3Ib;;'6%<2n");
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      //  // Unstable assertion: assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      
      jRip_NumericAntd0.value = 62.8213732;
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(4788);
      boolean boolean0 = jRip_NumericAntd0.covers((Instance) binarySparseInstance0);
      //  // Unstable assertion: assertFalse(boolean0);
  }

  //Test case number: 12
  /*
   * 3 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.covers(Lweka/core/Instance;)Z: I13 Branch 60 IFNE L907 - false
   * Goal 2. weka.classifiers.rules.JRip$NumericAntd.covers(Lweka/core/Instance;)Z: I22 Branch 61 IFNE L908 - false
   * Goal 3. weka.classifiers.rules.JRip$NumericAntd.covers(Lweka/core/Instance;)Z: I35 Branch 62 IFLE L909 - true
   */

  @Test
  public void test12()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("8118");
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      int[] intArray0 = new int[3];
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2.0, intArray0, 2765);
      boolean boolean0 = jRip_NumericAntd0.covers((Instance) binarySparseInstance0);
      assertEquals(3, jRip0.getFolds());
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
      assertTrue(boolean0);
      assertEquals(Double.NaN, jRip_NumericAntd0.getSplitPoint(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, jRip_NumericAntd0.getCover(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertFalse(jRip0.getDebug());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
  }

  //Test case number: 13
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getMeasure(Ljava/lang/String;)D: I8 Branch 83 IFNE L451 - true
   */

  @Test
  public void test13()  throws Throwable  {
      JRip jRip0 = new JRip();
      // Undeclared exception!
      try {
        double double0 = jRip0.getMeasure("8118");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // 8118 not supported (RIPPER)
         //
      }
  }

  //Test case number: 14
  /*
   * 4 covered goals:
   * Goal 1. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I13 Branch 73 IFEQ L377 - false
   * Goal 2. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I42 Branch 74 IFEQ L383 - false
   * Goal 3. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I71 Branch 75 IFEQ L389 - false
   * Goal 4. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I100 Branch 76 IFEQ L395 - false
   */

  @Test
  public void test14()  throws Throwable  {
      JRip jRip0 = new JRip();
      String[] stringArray0 = jRip0.getOptions();
      jRip0.setOptions(stringArray0);
      assertEquals(2, jRip0.getOptimizations());
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
  }

  //Test case number: 15
  /*
   * 6 covered goals:
   * Goal 1. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I13 Branch 73 IFEQ L377 - true
   * Goal 2. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I42 Branch 74 IFEQ L383 - true
   * Goal 3. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I71 Branch 75 IFEQ L389 - true
   * Goal 4. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I100 Branch 76 IFEQ L395 - true
   * Goal 5. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I132 Branch 77 IFNE L401 - false
   * Goal 6. weka.classifiers.rules.JRip.setOptions([Ljava/lang/String;)V: I151 Branch 78 IFNE L402 - false
   */

  @Test
  public void test15()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertFalse(jRip0.getDebug());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      
      String[] stringArray0 = new String[2];
      stringArray0[0] = "MED";
      stringArray0[1] = "~{#bgRJa8-";
      jRip0.setOptions(stringArray0);
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
  }

  //Test case number: 16
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.getAntds()Lweka/core/FastVector;: root-Branch
   */

  @Test
  public void test16()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      FastVector fastVector0 = jRip_RipperRule0.getAntds();
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(3, jRip0.getFolds());
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
  }

  //Test case number: 17
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.getRevision()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test17()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      String string0 = jRip_RipperRule0.getRevision();
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(3, jRip0.getFolds());
      assertEquals("8118", string0);
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
  }

  //Test case number: 18
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.size()D: root-Branch
   */

  @Test
  public void test18()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      double double0 = jRip_RipperRule0.size();
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 19
  /*
   * 4 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$RipperRule.setConsequent(D)V: root-Branch
   * Goal 2. weka.classifiers.rules.JRip$RipperRule.<init>(Lweka/classifiers/rules/JRip;)V: root-Branch
   * Goal 3. weka.classifiers.rules.JRip$RipperRule.copy()Ljava/lang/Object;: root-Branch
   * Goal 4. weka.classifiers.rules.JRip$RipperRule.getConsequent()D: root-Branch
   */

  @Test
  public void test19()  throws Throwable  {
      JRip jRip0 = new JRip();
      JRip.RipperRule jRip_RipperRule0 = jRip0.new RipperRule();
      JRip.RipperRule jRip_RipperRule1 = (JRip.RipperRule)jRip_RipperRule0.copy();
      assertNotSame(jRip_RipperRule1, jRip_RipperRule0);
      assertEquals((-1.0), jRip_RipperRule0.getConsequent(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals((-1.0), jRip_RipperRule1.getConsequent(), 0.01D);
  }

  //Test case number: 20
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getDebug()Z: root-Branch
   */

  @Test
  public void test20()  throws Throwable  {
      JRip jRip0 = new JRip();
      boolean boolean0 = jRip0.getDebug();
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertFalse(boolean0);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
  }

  //Test case number: 21
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getCheckErrorRate()Z: root-Branch
   */

  @Test
  public void test21()  throws Throwable  {
      JRip jRip0 = new JRip();
      boolean boolean0 = jRip0.getCheckErrorRate();
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertTrue(boolean0);
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
  }

  //Test case number: 22
  /*
   * 3 covered goals:
   * Goal 1. weka.classifiers.rules.JRip.setCheckErrorRate(Z)V: root-Branch
   * Goal 2. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I111 Branch 80 IFNE L422 - false
   * Goal 3. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I126 Branch 81 IFNE L425 - true
   */

  @Test
  public void test22()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertTrue(jRip0.getCheckErrorRate());
      
      jRip0.setCheckErrorRate(false);
      String[] stringArray0 = jRip0.getOptions();
      assertFalse(jRip0.getCheckErrorRate());
  }

  //Test case number: 23
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.listOptions()Ljava/util/Enumeration;: root-Branch
   */

  @Test
  public void test23()  throws Throwable  {
      JRip jRip0 = new JRip();
      Enumeration enumeration0 = jRip0.listOptions();
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
  }

  //Test case number: 24
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.checkErrorRateTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test24()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.checkErrorRateTipText();
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals("Whether check for error rate >= 1/2 is included in stopping criterion.", string0);
      assertEquals(3, jRip0.getFolds());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 25
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.setMinNo(D)V: root-Branch
   */

  @Test
  public void test25()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      
      jRip0.setMinNo(1.0);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 26
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.foldsTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test26()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.foldsTipText();
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals("Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.", string0);
      assertTrue(jRip0.getUsePruning());
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 27
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getSeed()J: root-Branch
   */

  @Test
  public void test27()  throws Throwable  {
      JRip jRip0 = new JRip();
      long long0 = jRip0.getSeed();
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, long0);
      assertFalse(jRip0.getDebug());
      assertTrue(jRip0.getUsePruning());
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 28
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.optimizationsTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test28()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.optimizationsTipText();
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertFalse(jRip0.getDebug());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(3, jRip0.getFolds());
      assertEquals("The number of optimization runs.", string0);
  }

  //Test case number: 29
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.enumerateMeasures()Ljava/util/Enumeration;: root-Branch
   */

  @Test
  public void test29()  throws Throwable  {
      JRip jRip0 = new JRip();
      Enumeration enumeration0 = jRip0.enumerateMeasures();
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 30
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.seedTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test30()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.seedTipText();
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertFalse(jRip0.getDebug());
      assertEquals("The seed used for randomizing the data.", string0);
  }

  //Test case number: 31
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getRevision()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test31()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.getRevision();
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals("8118", string0);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
  }

  //Test case number: 32
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getFolds()I: root-Branch
   */

  @Test
  public void test32()  throws Throwable  {
      JRip jRip0 = new JRip();
      int int0 = jRip0.getFolds();
      assertEquals(3, int0);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 33
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.setSeed(J)V: root-Branch
   */

  @Test
  public void test33()  throws Throwable  {
      JRip jRip0 = new JRip();
      jRip0.setSeed((long) 3);
      assertEquals(3L, jRip0.getSeed());
  }

  //Test case number: 34
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.debugTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test34()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.debugTipText();
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals("Whether debug information is output to the console.", string0);
  }

  //Test case number: 35
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getUsePruning()Z: root-Branch
   */

  @Test
  public void test35()  throws Throwable  {
      JRip jRip0 = new JRip();
      boolean boolean0 = jRip0.getUsePruning();
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(3, jRip0.getFolds());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(boolean0);
  }

  //Test case number: 36
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getMinNo()D: root-Branch
   */

  @Test
  public void test36()  throws Throwable  {
      JRip jRip0 = new JRip();
      double double0 = jRip0.getMinNo();
      assertFalse(jRip0.getDebug());
      assertEquals(3, jRip0.getFolds());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, double0, 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
  }

  //Test case number: 37
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.setOptimizations(I)V: root-Branch
   */

  @Test
  public void test37()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertEquals(2, jRip0.getOptimizations());
      
      jRip0.setOptimizations(0);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 38
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getOptimizations()I: root-Branch
   */

  @Test
  public void test38()  throws Throwable  {
      JRip jRip0 = new JRip();
      int int0 = jRip0.getOptimizations();
      assertFalse(jRip0.getDebug());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, int0);
      assertEquals(3, jRip0.getFolds());
  }

  //Test case number: 39
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.main([Ljava/lang/String;)V: root-Branch
   */

  @Test
  public void test39()  throws Throwable  {
      String[] stringArray0 = new String[8];
      JRip.main(stringArray0);
  }

  //Test case number: 40
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getRuleStats(I)Lweka/classifiers/rules/RuleStats;: root-Branch
   */

  @Test
  public void test40()  throws Throwable  {
      JRip jRip0 = new JRip();
      // Undeclared exception!
      try {
        RuleStats ruleStats0 = jRip0.getRuleStats(9386);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  //Test case number: 41
  /*
   * 6 covered goals:
   * Goal 1. weka.classifiers.rules.JRip.setUsePruning(Z)V: root-Branch
   * Goal 2. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I96 Branch 79 IFEQ L419 - true
   * Goal 3. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I111 Branch 80 IFNE L422 - true
   * Goal 4. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I126 Branch 81 IFNE L425 - false
   * Goal 5. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I142 Branch 82 IF_ICMPGE L428 - true
   * Goal 6. weka.classifiers.rules.JRip.getOptions()[Ljava/lang/String;: I142 Branch 82 IF_ICMPGE L428 - false
   */

  @Test
  public void test41()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertTrue(jRip0.getUsePruning());
      
      jRip0.setUsePruning(false);
      String[] stringArray0 = jRip0.getOptions();
      assertFalse(jRip0.getUsePruning());
  }

  //Test case number: 42
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.setFolds(I)V: root-Branch
   */

  @Test
  public void test42()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertEquals(3, jRip0.getFolds());
      
      jRip0.setFolds(0);
      assertEquals(0, jRip0.getFolds());
  }

  //Test case number: 43
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getRuleset()Lweka/core/FastVector;: root-Branch
   */

  @Test
  public void test43()  throws Throwable  {
      JRip jRip0 = new JRip();
      FastVector fastVector0 = jRip0.getRuleset();
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 44
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.usePruningTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test44()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.usePruningTipText();
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertEquals("Whether pruning is performed.", string0);
  }

  //Test case number: 45
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.setDebug(Z)V: root-Branch
   */

  @Test
  public void test45()  throws Throwable  {
      JRip jRip0 = new JRip();
      assertFalse(jRip0.getDebug());
      
      jRip0.setDebug(true);
      assertTrue(jRip0.getDebug());
  }

  //Test case number: 46
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.minNoTipText()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test46()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.minNoTipText();
      assertEquals("The minimum total weight of the instances in a rule.", string0);
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(3, jRip0.getFolds());
      assertEquals(1L, jRip0.getSeed());
  }

  //Test case number: 47
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip.getCapabilities()Lweka/core/Capabilities;: root-Branch
   */

  @Test
  public void test47()  throws Throwable  {
      JRip jRip0 = new JRip();
      // Undeclared exception!
      try {
        jRip0.buildClassifier((Instances) null);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // weka/core/WekaPackageManager
         //
      }
  }

  //Test case number: 48
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip.globalInfo()Ljava/lang/String;: root-Branch
   * Goal 2. weka.classifiers.rules.JRip.getTechnicalInformation()Lweka/core/TechnicalInformation;: root-Branch
   */

  @Test
  public void test48()  throws Throwable  {
      JRip jRip0 = new JRip();
      String string0 = jRip0.globalInfo();
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals("This class implements a propositional rule learner, Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was proposed by William W. Cohen as an optimized version of IREP. \n\nThe algorithm is briefly described as follows: \n\nInitialize RS = {}, and for each class from the less prevalent one to the more frequent one, DO: \n\n1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and examples is 64 bits greater than the smallest DL met so far, or there are no positive examples, or the error rate >= 50%. \n\n1.1. Grow phase:\nGrow one rule by greedily adding antecedents (or conditions) to the rule until the rule is perfect (i.e. 100% accurate).  The procedure tries every possible value of each attribute and selects the condition with highest information gain: p(log(p/t)-log(P/T)).\n\n1.2. Prune phase:\nIncrementally prune each rule and allow the pruning of any final sequences of the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n2. Optimization stage:\n after generating the initial ruleset {Ri}, generate and prune two variants of each rule Ri from randomized data using procedure 1.1 and 1.2. But one variant is generated from an empty rule while the other is generated by greedily adding antecedents to the original rule. Moreover, the pruning metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each variant and the original rule is computed.  The variant with the minimal DL is selected as the final representative of Ri in the ruleset.After all the rules in {Ri} have been examined and if there are still residual positives, more rules are generated based on the residual positives using Building Stage again. \n3. Delete the rules from the ruleset that would increase the DL of the whole ruleset if it were in it. and add resultant ruleset to RS. \nENDDO\n\nNote that there seem to be 2 bugs in the original ripper program that would affect the ruleset size and accuracy slightly.  This implementation avoids these bugs and thus is a little bit different from Cohen's original implementation. Even after fixing the bugs, since the order of classes with the same frequency is not defined in ripper, there still seems to be some trivial difference between this implementation and the original ripper, especially for audiology data in UCI repository, where there are lots of classes of few instances.\n\nDetails please see:\n\nWilliam W. Cohen: Fast Effective Rule Induction. In: Twelfth International Conference on Machine Learning, 115-123, 1995.\n\nPS.  We have compared this implementation with the original ripper implementation in aspects of accuracy, ruleset size and running time on both artificial data \"ab+bcd+defg\" and UCI datasets.  In all these aspects it seems to be quite comparable to the original ripper implementation.  However, we didn't consider memory consumption optimization in this implementation.\n\n", string0);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
  }

  //Test case number: 49
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.copy()Ljava/lang/Object;: root-Branch
   */

  @Test
  public void test49()  throws Throwable  {
      JRip jRip0 = new JRip();
      ArrayList<String> arrayList0 = new ArrayList<String>();
      Attribute attribute0 = new Attribute("Should never happen: dl in building stage NaN or infinite!", (List<String>) arrayList0);
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      JRip.NominalAntd jRip_NominalAntd1 = (JRip.NominalAntd)jRip_NominalAntd0.copy();
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, jRip_NominalAntd1.getAttrValue(), 0.01D);
      assertTrue(jRip0.getUsePruning());
      assertEquals(0.0, jRip_NominalAntd1.getMaxInfoGain(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd1.getAccu(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2, jRip0.getOptimizations());
      assertFalse(jRip0.getDebug());
      assertEquals(Double.NaN, jRip_NominalAntd1.getCover(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd1.getAccuRate(), 0.01D);
  }

  //Test case number: 50
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.getRevision()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test50()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      String string0 = jRip_NominalAntd0.getRevision();
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals("8118", string0);
      assertEquals(3, jRip0.getFolds());
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 51
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NominalAntd.toString()Ljava/lang/String;: root-Branch
   */

  @Test
  public void test51()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      String string0 = jRip_NominalAntd0.toString();
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertEquals("Set the number of folds for cross validation. = ", string0);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
  }

  //Test case number: 52
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$Antd.getAccu()D: root-Branch
   */

  @Test
  public void test52()  throws Throwable  {
      JRip jRip0 = new JRip();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Attribute attribute0 = new Attribute("weka.classifiers.rules.JRip$Antd", (List<String>) linkedList0);
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      double double0 = jRip_NominalAntd0.getAccu();
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(Double.NaN, double0, 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
  }

  //Test case number: 53
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$Antd.getAccuRate()D: root-Branch
   */

  @Test
  public void test53()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      double double0 = jRip_NominalAntd0.getAccuRate();
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, double0, 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
  }

  //Test case number: 54
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$Antd.getCover()D: root-Branch
   */

  @Test
  public void test54()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      double double0 = jRip_NumericAntd0.getCover();
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, double0, 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getSplitPoint(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
  }

  //Test case number: 55
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$Antd.getMaxInfoGain()D: root-Branch
   */

  @Test
  public void test55()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("", "");
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      double double0 = jRip_NominalAntd0.getMaxInfoGain();
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(0.0, double0, 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAttrValue(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
  }

  //Test case number: 56
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$Antd.getAttrValue()D: root-Branch
   * Goal 2. weka.classifiers.rules.JRip$NominalAntd.<init>(Lweka/classifiers/rules/JRip;Lweka/core/Attribute;)V: root-Branch
   */

  @Test
  public void test56()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NominalAntd jRip_NominalAntd0 = jRip0.new NominalAntd(attribute0);
      double double0 = jRip_NominalAntd0.getAttrValue();
      assertEquals(Double.NaN, jRip_NominalAntd0.getCover(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getCheckErrorRate());
      assertTrue(jRip0.getUsePruning());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(0.0, jRip_NominalAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(Double.NaN, double0, 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccu(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, jRip_NominalAntd0.getAccuRate(), 0.01D);
  }

  //Test case number: 57
  /*
   * 1 covered goal:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.getSplitPoint()D: root-Branch
   */

  @Test
  public void test57()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("Set the number of folds for cross validation.", (-1190));
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      double double0 = jRip_NumericAntd0.getSplitPoint();
      assertEquals(Double.NaN, double0, 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NumericAntd0.getCover(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertFalse(jRip0.getDebug());
  }

  //Test case number: 58
  /*
   * 2 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.copy()Ljava/lang/Object;: root-Branch
   * Goal 2. weka.classifiers.rules.JRip$Antd.getAttr()Lweka/core/Attribute;: root-Branch
   */

  @Test
  public void test58()  throws Throwable  {
      JRip jRip0 = new JRip();
      Attribute attribute0 = new Attribute("A PhD thesis.", (String) null);
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      JRip.NumericAntd jRip_NumericAntd1 = (JRip.NumericAntd)jRip_NumericAntd0.copy();
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertTrue(jRip0.getUsePruning());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertNotSame(jRip_NumericAntd0, jRip_NumericAntd1);
      assertEquals(3, jRip0.getFolds());
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd1.getAttrValue(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getCover(), 0.01D);
      assertFalse(jRip0.getDebug());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, jRip_NumericAntd1.getSplitPoint(), 0.01D);
      assertTrue(jRip0.getCheckErrorRate());
  }

  //Test case number: 59
  /*
   * 4 covered goals:
   * Goal 1. weka.classifiers.rules.JRip$NumericAntd.getRevision()Ljava/lang/String;: root-Branch
   * Goal 2. weka.classifiers.rules.JRip$NumericAntd.<init>(Lweka/classifiers/rules/JRip;Lweka/core/Attribute;)V: root-Branch
   * Goal 3. weka.classifiers.rules.JRip$Antd.<init>(Lweka/classifiers/rules/JRip;Lweka/core/Attribute;)V: root-Branch
   * Goal 4. weka.classifiers.rules.JRip.<init>()V: root-Branch
   */

  @Test
  public void test59()  throws Throwable  {
      JRip jRip0 = new JRip();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Attribute attribute0 = new Attribute("weka.classifiers.rules.JRip$Antd", (List<String>) linkedList0);
      JRip.NumericAntd jRip_NumericAntd0 = jRip0.new NumericAntd(attribute0);
      String string0 = jRip_NumericAntd0.getRevision();
      assertEquals("8118", string0);
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(Double.NaN, jRip_NumericAntd0.getCover(), 0.01D);
      assertEquals(2.0, jRip0.getMinNo(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccu(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getSplitPoint(), 0.01D);
      assertEquals(Double.NaN, jRip_NumericAntd0.getAccuRate(), 0.01D);
      assertEquals(3, jRip0.getFolds());
      assertEquals(0.0, jRip_NumericAntd0.getMaxInfoGain(), 0.01D);
      assertEquals(2, jRip0.getOptimizations());
      assertEquals(Double.NaN, jRip_NumericAntd0.getAttrValue(), 0.01D);
      assertEquals(1L, jRip0.getSeed());
      assertFalse(jRip0.getDebug());
  }
}
